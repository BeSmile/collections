# linux负载均衡
负载均衡是用反向代理的原理实现的。
#### 正向代理以及反向代理关系图
![盗图知乎](https://pic1.zhimg.com/80/480c1c45d2565e2f92fd930d25b73a18_hd.jpg)
##### 使用docker部署nginx负载均衡
###### 创建多个nginx服务器
<pre>winpty docker run -d --name work-nginx_01 -p 80:80 -v /E:/phpstudy/WWW:/usr/share/nginx/html nginx
winpty docker run -d --name work-nginx_02 -p 8080:80 -v /E:/phpstudy/WWW:/usr/share/nginx/html nginx</pre>
```因为是本机创建的多个nginx服务器所以需要映射不同的端口```
###### 修改nginx配置文件
打开<code>/etc/nginx/conf.d/default.conf</code>添加代码
<pre>upstream 172.17.0.4 {
    ip_hash;
    server 172.17.0.4:8080 weight=1;
    server 172.17.0.5:80 weight=3;
}</pre>
> * ip_hash  如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。有效解决session问题
> * fair（第三方） 根据服务器响应时间来分配
> * url_hash
###### 每个设备的状态有：
> * weight 默认为1，负载的权重就越大
> * down 设置当前服务器不参与负载
> * max_fails 允许失败次数
> * fail_timeout:max_fails 失败后，暂停的时间
> * backup 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。
###### 添加监听server
<pre>server {
   listen 80;
   server_name 172.17.0.4;
   location /{
      # 反向代理的主机头
      proxy_pass  http://172.17.0.4;
      proxy_set_header Host   $host;
      proxy_set_header   X-Real-IP        $remote_addr;
      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
   }
}</pre>
###### 配置实例
<pre>upstream 172.17.0.4 {
    ip_hash;
    server 172.17.0.4:8080 weight=3;
    server 172.17.0.5:80 weight=3;
}
server {
   listen 80;
   server_name 172.17.0.4;
   location /{
      # 反向代理的主机头
      proxy_pass  http://172.17.0.4;
      proxy_set_header Host   $host;
      proxy_set_header   X-Real-IP        $remote_addr;
      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
   }
}
server {
    listen 8080 default_server;
    listen [::]:8080 default_server ipv6only=on;
    server_name  *.exs.dev localhost;
    
    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html/exueshu/public;
    index  index.php index.html index.htm;
    autoindex on;
    autoindex_exact_size on;
    autoindex_localtime on; 
    try_files $uri $uri/ /index.php?$query_string;
        if (!-e $request_filename){  
            rewrite ^/(.*) /index.php last;  
        }
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
 
    location ~ \.php(.*)$ {
    fastcgi_pass 172.17.0.3:9000;
    fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/html/exueshu/public$fastcgi_script_name;
        fastcgi_param  SCRIPT_NAME      $fastcgi_script_name;
        fastcgi_split_path_info ^(.+\.php)(.*)$;     #增加这一句  
        fastcgi_param PATH_INFO $fastcgi_path_info;    #增加这一句
        include  fastcgi_params;
     }
    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
  
    location /assets  {
        alias /usr/share/nginx/html/exueshu/public/assets;
    }
}</pre>