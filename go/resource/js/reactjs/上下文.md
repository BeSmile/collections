# react上下文
在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用强大的”context” API解决上述问题。例如A包含了B,B包含了C,则C组件可以获取到A组件定义的context
<pre>&lt;A>
    &lt;B>
        &lt;C/>
    &lt;/B>
&lt;/A></pre>
<strong>必须嵌套否则无法获取顶级父组件内的context内容</strong>

### 定义context
设置context需要定义<code>childContextTypes </code>和<code>getChildContext </code>
### 实际代码
<pre>class Frame extends Component{
  getChildContext() {
    return {global: "purple"};
  }
  render() {
    const {children} = this.props;
    return (
        &lt;div>
          {children}
        &lt;/div>
    )
  }
}

Frame.childContextTypes = {
  global: PropTypes.string
}

class Child extends Component {
  render(){
    return (
      &lt;div>
        {this.context.global}
      &lt;/div>
    )
  }
}

Child.contextTypes = {
  global: PropTypes.string
}

class App extends Component {
  constructor(props) {
    super(props);
  }
  componentDidMount() {

  }
  
  render() {
    return (
      &lt;Frame>
        &lt;Child/>
      &lt;/Frame>
    );
  }
}</pre>
### 尽量不要在context中使用state更换
<pre>class Frame extends Component{
  state = {
    global: 'uyse'
  }
  getChildContext() {
    const {global} = this.state;
    return {global};
  }
  render() {
    const {children} = this.props;
    return (
        &lt;div>
          {children}
        &lt;/div>
    )
  }
}

Frame.childContextTypes = {
  global: PropTypes.string
}

class Child extends Component {
  render(){
    console.log(this.context)
    return (
      &lt;div>
        {this.context.global}
      &lt;/div>
    )
  }
}

Child.contextTypes = {
  global: PropTypes.string
}

class App extends Component {
  constructor(props) {
    super(props);
  }
  componentDidMount() {

  }
  
  render() {
    return (
      &lt;Frame>
        &lt;Child/>
      &lt;/Frame>
    );
  }
}
</pre>
因为组件提供的context值改变，后代元素如果 shouldComponentUpdate 返回 false 那么context的将不会更新
### 如何安全的使用
组件内不使用任何state,在调用组件的容器中更新state,通过props传递来更新内容
<pre>class Frame extends Component{
  getChildContext() {
    const {global} = this.props;
    return {global};
  }
  componentDidMount() {

  }
  render() {
    const {children} = this.props;
    return (
        &lt;div>
          {children}
        &lt;/div>
    )
  }
}

Frame.childContextTypes = {
  global: PropTypes.string
}

class Child extends Component {
  render(){
    return (
      &lt;div>
        {this.context.global}
      &lt;/div>
    )
  }
}

Child.contextTypes = {
  global: PropTypes.string
}

class App extends Component {
  constructor(props) {
    super(props);
  }
  componentDidMount() {

  }
  
  render() {
    return (
      &lt;Frame global="dist">
        &lt;Child/>
      &lt;/Frame>
    );
  }
}</pre>
<strong><code>prop</code>不但可以传递基本类型变量也可以传递复杂类型对象,例如Object</strong>